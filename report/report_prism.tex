\documentclass[12pt]{report}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{amsmath}

\begin{document}

\begin{titlepage}
\begin{center}

\hfill

\bigskip
\huge{Technical Report} 
\vfill
\bigskip 
\Huge 
\bigskip Efficient, Proximity-Preserving Node Overlap Removal \par 
\vfill
\Large Claire Pennarun \par 
		Tatiana Rocher
\vfill
\Large Bordeaux 1 \par \Large Projet d'Etude et de Recherche		
		\bigskip 
\bigskip

\Large
\today
\end{center}
\end{titlepage}

\tableofcontents
\newpage

\chapter{Subject presentation and state of the art}

%Partie "domaine general : graph drawing"
A graph is a data structure encoding information with the use of nodes and edges (which are binary relations between nodes).

Graph drawing aims to represent given information as a graph, generally through a "node-link" layout, letting nodes and edges be displayed. 

\bigskip
%Partie "domaine specifique : node overlap + etat de l'art"
Most of the layout algorithms consider nodes as points, but some need to let appear additional information as labels. For example, London subway maps would be useless without the indication of the stations on the lines.

This could lead to an overlap of some nodes. That must be avoided, as it clearly confuses the understanding of the graph.

Many approachs are generally considered ; the easiest to apply is to "scale" the layout until no overlaps occur. This method has the advantage to preserve the global shape of the layout, but the area of the graph can become very inconvenient. That is why a compromise between the preservation of the shape of the graph and a minimization of the total area has to be found.

Different algorithms have been devised to answer the problem. 

\bigskip
%Partie : "presentation du projet"
Our project consists in understanding the algorithm PRISM proposed by Gansner and Hu in \cite{GH08} and in analyzing the feasability of its implementation as a plugin for the Tulip software. %(ici, mettre une reference pour Tulip !)


%% Faire une section "notations" : au debut de PRISM ou a la fin de l'intro ?
% notations des graphes, position d'un noeud, largeur / longueur

\chapter{PRISM algorithm}

\section{Description of the algorithm}

The PRISM algorithm focuses on two main constraints for the final layout of the graph. First, the area taken by the layout must be minimal. The second constraint is to preserve the global "shape" of the original layout by maintaining all proximity relations between the nodes.

The PRISM algorithm runs in two main steps ; in a first step, it removes iteratively the overlaps between near nodes of the given graph $G$. Then it finds the non-near overlaping nodes and removes these overlaps as well.

We consider for this algorithm that a node $i$ has a certain width $w_i$ and height $h_i$, thus forming a rectangle containing the label, likely to cause overlaps.

\subsection{Overlap removal between near nodes}

\subsubsection{Use of a proximity graph - Delaunay Triangulation}

To find easily the overlaps between near nodes of the graph $G$, it will efficient to work on a proximity graph of $G$. 

A \emph{proximity graph} is a graph in which two vertices are connected by an edge if (and only if) they satisfy a given geometrical property.

\bigskip

The \emph{Delaunay triangulation} (DT) of a graph $G$ is a triangulation of the graph such that none of the circumscribed circles of the triangles in DT(G) contains a vertex. This particular triangulation also maximises the minimum angle of the triangles found.

The Delaunay triangulation of $G$, as a triangulation, is also a planar graph, and has thus at most $3n -6$ edges (if $|V(G)| = n$), which is a very practical parameter for the algorithm.

\bigskip

The nearest neighbors of a vertex $v \in V(G)$ tend to form triangles with $v$ and in particular, the closest neighbor of $v$ has an edge with $v$ in DT(G), as the nearest neighbor graph of $G$ is a subgraph of DT(G).

In the PRISM algorithm, we consider that the near nodes in $G$ are connected by an edge in the Delaunay triangulation of $G$.

Thus, the algorithm's first goal is to remove overlaps on the edges of the Delaunay triangulation of $G$.

\subsubsection{Ideal edge length}
The idea is to find the "ideal length" of the Delaunay triangulation edges : the "ideal length" of an edge is such that the two edge ends have no overlap.

\bigskip
In order to do that, we calculate an \emph{overlap factor} $f_{ij}$ for each edge $(i,j)$ ($i,j \in V(G)$) of the Delaunay triangulation of $G$ :

\[ f_{ij} = \max ( \min (\frac{w_i/2 + w_j/2}{x_i - x_j}, 
\frac{h_i/2 + h_j/2}{y_i - y_j}), 1)\]

where $(x_i,y_i)$ are the coordinates of vertex $i$, $w_i$ its width and $h_i$ its height.

If two nodes $i$ and $j$ have no overlap, then $f_{ij} = 1$. 
If $i$ and $j$ do overlap, then that overlap can be removed by expanding the edge $(i,j)$ by the overlap factor found $f_{ij}$. %% Ajouter figure

\bigskip
Thus, the "ideal length" of an edge of the Delaunay triangulation is $l_ij = f_{ij}||p_i - p_j||$, where $p_i$ is the initial set of coordinates of the node $i$.

We now want to find coordinates for the nodes of the initial graph such that the edges length in $DT(G)$ are close to their ideal length.

\subsubsection{Proximity stress model}

Finding this new set of coordinates means minimizing the following sum :

\[ \sum_{i,j \in E(DT(G))} w_{ij}(||p_i - p_j|| - l_{ij})^2\]

where $w_{ij}$ is a classic weighting factor, used to equalize the contributions to the stress from the different edges and $l_{ij}$ is the overlap factor.

But there are some situations where keeping $l_{ij}$ is not a good idea (see figure) % faire un dessin d'apres l'article

We thus avoid removing the big overlaps in one iteration only.
So we have to replace $l_{ij}$ by $\min(l_{ij},s)$, where $s > 1$ is a overlap limiting factor. The authors found that $s = 1.5$ worked well.

We now want to minimize :

\[ \sum_{i,j \in E(DT(G))} w_{ij}(||p_i - p_j|| - \min(l_{ij},s))^2\]

This type of sum is called a "stress function", in analogy with the well studied \emph{stress model}. %mettre reference !
The above sum is called the \emph{proximity stress model}.


\bigskip


\subsubsection{Termination}

\subsection{Overlap removal between non-near nodes}

Why do we need a second stage ?
\subsubsection{Scan-line algorithm}

\bigskip
\begin{algorithm}[H]
\caption{PRISM}
\KwIn{$p_i^0$ : coordinates of each vertex  \\
	 width $w_i$ and height $h_i$ of each vertex ($i = 1,2,...,|V|$)}
	 
\Repeat{}{$G_{DT}$ : proximity graph of $G$ by Delaunay triangulation \\
	\For{all edges of $G_{DT}$}
	{Compute the overlap factor}
	$\{p_i\}$ : solution of the proximity stress model
	
	$p_i^0 = p_i$
}	
(no more overlaps along edges of $G_{DT}$)
\BlankLine
\Repeat{}{$G_{DT}$ : proximity graph of $G$ by Delaunay triangulation \\
	Find overlaps in $G$ through a scan-line algorithm \\
	Add the overlapping edges to $G_{DT}$ \\
	\For{all edges of $G_{DT}$}
	{Compute the overlap factor}
	$\{p_i\}$ : solution of the proximity stress model
	
	$p_i^0 = p_i$
}	
(no more overlaps found by the scan-line algorithm)
\end{algorithm}

\subsection{Dissimilarity metrics}

\subsubsection{Area}
\subsubsection{Edge length ratio}
\subsubsection{Vertices displacement}

\section{Complexity}

\chapter{Implementation within Tulip}

\section{Tulip framework}

Tulip presentation

Tulip node structure (problems with label size)

Solution : forcing node size and labels

\section{Resolution of the stress model}
\subsubsection{Stress majorization}
Not possible natively in Tulip

Too many dependencies in GraphViz

Use of Eigen possible ?
\subsubsection{Newton-Raphson method - Kamada \& Kawai}
Implementation done ?
\section{Scan-line algorithm}
Implementation details
\chapter{Tests and results}

\section{Use of GraphViz}

\chapter{Conclusion}

\bibliographystyle{plain}
\bibliography{report_prism}

\end{document}
